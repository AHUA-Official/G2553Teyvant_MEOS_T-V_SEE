	.module main.c
	.area text(rom, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
_Buffer::
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 0,0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.dbsym e Buffer _Buffer A[64:64]c
_TX_ADDRESS::
	.blkb 2
	.area idata
	.byte 52,'C
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 2
	.area idata
	.byte 16,16
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.blkb 1
	.area idata
	.byte 1
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.dbsym e TX_ADDRESS _TX_ADDRESS A[5:5]c
_accept_flag::
	.blkb 1
	.area idata
	.byte 0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.dbsym e accept_flag _accept_flag c
_accept_time::
	.blkb 2
	.area idata
	.word 0
	.area data(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.dbsym e accept_time _accept_time i
	.area text(rom, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
	.dbfunc e main _main fV
;         Get_SO -> R10
	.even
_main::
	sbiw R28,1
	.dbline -1
	.dbline 127
; //ICC-AVR application builder : 2006-02-12 14:00:00
; // Target : ATmega48
; // Crystal: 8.000Mhz
; // Author:  jackyan
; // Oled Type : white
; //#define fosc 8000000
; //#define baud 9600
; #include "iom48v.h"
; #include "macros.h"
; #include "defs.h"
; /*-----------------------------------------------------------------------------
;    Global Defines
; ------------------------------------------------------------------------------*/
; unsigned char   key_debug;
; unsigned char 	Buffer[]={
; 0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
; 0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
; 0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
; 0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
; };
; #define TX_ADR_WIDTH    5   // 5 bytes TX(RX) address width
; #define TX_PLOAD_WIDTH  20  // 16 bytes TX payload
; unsigned char TX_ADDRESS[TX_ADR_WIDTH]  = {0x34,0x43,0x10,0x10,0x01}; // Define a static TX address
; void init_CPU (void);
; void delayms(unsigned short	dly);//当dly=1时，延时的时间是1ms  4MHz晶震
; void INIT_io(void);
; void RX_Mode(void);
; void TX_Mode(void);
; void delay(void);
; unsigned char SPI_Write_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes);
; unsigned char SPI_Read_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes);
; unsigned char SPI_RW_Reg(unsigned char reg, unsigned char value);
; unsigned char SPI_Read(unsigned char reg);
; void clear_buf(unsigned char	*ptr,unsigned char number);
; unsigned char accept_flag=0;
; unsigned int accept_time=0;
; //****************************************************************//
; // SPI(nRF24L01) commands
; #define READ_REG        0x00  // Define read command to register
; #define WRITE_REG       0x20  // Define write command to register
; #define RD_RX_PLOAD     0x61  // Define RX payload register address
; #define WR_TX_PLOAD     0xA0  // Define TX payload register address
; #define FLUSH_TX        0xE1  // Define flush TX register command
; #define FLUSH_RX        0xE2  // Define flush RX register command
; #define REUSE_TX_PL     0xE3  // Define reuse TX payload register command
; //#define NOP             0xFF  // Define No Operation, might be used to read status register
; //***************************************************//
; // SPI(nRF24L01) registers(addresses)
; #define CONFIG          0x00  // 'Config' register address
; #define EN_AA           0x01  // 'Enable Auto Acknowledgment' register address
; #define EN_RXADDR       0x02  // 'Enabled RX addresses' register address
; #define SETUP_AW        0x03  // 'Setup address width' register address
; #define SETUP_RETR      0x04  // 'Setup Auto. Retrans' register address
; #define RF_CH           0x05  // 'RF channel' register address
; #define RF_SETUP        0x06  // 'RF setup' register address
; #define STATUS          0x07  // 'Status' register address
; #define OBSERVE_TX      0x08  // 'Observe TX' register address
; #define CD              0x09  // 'Carrier Detect' register address
; #define RX_ADDR_P0      0x0A  // 'RX address pipe0' register address
; #define RX_ADDR_P1      0x0B  // 'RX address pipe1' register address
; #define RX_ADDR_P2      0x0C  // 'RX address pipe2' register address
; #define RX_ADDR_P3      0x0D  // 'RX address pipe3' register address
; #define RX_ADDR_P4      0x0E  // 'RX address pipe4' register address
; #define RX_ADDR_P5      0x0F  // 'RX address pipe5' register address
; #define TX_ADDR         0x10  // 'TX address' register address
; #define RX_PW_P0        0x11  // 'RX payload width, pipe0' register address
; #define RX_PW_P1        0x12  // 'RX payload width, pipe1' register address
; #define RX_PW_P2        0x13  // 'RX payload width, pipe2' register address
; #define RX_PW_P3        0x14  // 'RX payload width, pipe3' register address
; #define RX_PW_P4        0x15  // 'RX payload width, pipe4' register address
; #define RX_PW_P5        0x16  // 'RX payload width, pipe5' register address
; #define FIFO_STATUS     0x17  // 'FIFO Status Register' register address
; #define MAX_RT  	0x10  // Max #of TX retrans interrupt
; #define TX_DS   	0x20  // TX data sent interrupt
; #define RX_DR   	0x40  // RX data received
; //-----------------------------------------------------------------------------
; //------------------------------------------------------
; #define BIT(x)	           (1 << (x))
; #define SETBIT(x, y)   	   (x |= y)
; #define CLEARBIT(x, y) 	   (x &= ~y)
; #define CHECKBIT(x, y) 	   (x & y)
; #define BIT7 0x80
; #define BIT6 0x40
; #define BIT5 0x20
; #define BIT4 0x10
; #define BIT3 0x08
; #define BIT2 0x04
; #define BIT1 0x02
; #define BIT0 0x01
; /*#define nRF24L01_CSN        BIT4
; #define nRF24L01_SCK        BIT5
; #define nRF24L01_MOSI       BIT6
; #define nRF24L01_CE         BIT3
; #define nRF24L01_MISO 	    BIT7
; #define nRF24L01_IRQ  	    BIT0
; #define nRF24L01_CSNH       SETBIT(PORTD, BIT4)     
; #define nRF24L01_CSNL       CLEARBIT(PORTD, BIT4)   
; 
; #define nRF24L01_SCKH       SETBIT(PORTD,BIT5)      
; #define nRF24L01_SCKL       CLEARBIT(PORTD,BIT5)    
; 
; #define nRF24L01_MOSIH      SETBIT(PORTD,BIT6)     
; #define nRF24L01_MOSIL	    CLEARBIT(PORTD,BIT6)   
; 
; #define nRF24L01_CEH        SETBIT(PORTD,BIT3)     
; #define nRF24L01_CEL        CLEARBIT(PORTD,BIT3) */ 
; //-----------------------------------------------------------------------------
; #define nRF24L01_CSN        BIT6
; #define nRF24L01_SCK        BIT1
; #define nRF24L01_MOSI       BIT0
; #define nRF24L01_CE         BIT7
; #define nRF24L01_MISO 	    BIT3
; #define nRF24L01_IRQ  	    BIT2
; #define nRF24L01_CSNH       SETBIT(PORTD, BIT6)     
; #define nRF24L01_CSNL       CLEARBIT(PORTD, BIT6)   
; 
; #define nRF24L01_SCKH       SETBIT(PORTB,BIT1)      
; #define nRF24L01_SCKL       CLEARBIT(PORTB,BIT1)    
; 
; #define nRF24L01_MOSIH      SETBIT(PORTB,BIT0)     
; #define nRF24L01_MOSIL	    CLEARBIT(PORTB,BIT0)   
; 
; #define nRF24L01_CEH        SETBIT(PORTD,BIT7)     
; #define nRF24L01_CEL        CLEARBIT(PORTD,BIT7)
; //-----------------------------------------------------------------------------
; void main(void)
; {
	.dbline 128
;  	unsigned char Get_SO=0;
	clr R10
	.dbline 129
;     CLI();                   /* global interrupt disable */
	cli
	.dbline 130
;     init_CPU ();
	rcall _init_CPU
	.dbline 131
;     delayms(100);	//延时10ms*10=100ms
	ldi R16,100
	ldi R17,0
	rcall _delayms
	.dbline 132
;     delayms(100);	//延时10ms*10=100ms
	ldi R16,100
	ldi R17,0
	rcall _delayms
	.dbline 133
; 	RX_Mode();
	rcall _RX_Mode
	rjmp L3
L2:
	.dbline 135
; 	while(1)
; 	{		
	.dbline 137
; 		//	if(!(PINB& 0x01))
; 		if(!(PINB& 0x04))
	sbic 0x3,2
	rjmp L5
X0:
	.dbline 138
; 		{//nRF24L01 接收数据
	.dbline 139
; 			key_debug=SPI_Read(STATUS);			// read register STATUS's value
	ldi R16,7
	rcall _SPI_Read
	sts _key_debug,R16
	.dbline 140
; 			if(key_debug&RX_DR)					// if renRF24L01_CEive data ready (RX_DR) interrupt
	sbrs R16,6
	rjmp L7
X1:
	.dbline 141
; 				SPI_Read_Buf(RD_RX_PLOAD,Buffer,TX_PLOAD_WIDTH);// read renRF24L01_CEive payload from RX_FIFO buffer
	ldi R24,20
	std y+0,R24
	ldi R18,<_Buffer
	ldi R19,>_Buffer
	ldi R16,97
	rcall _SPI_Read_Buf
L7:
	.dbline 142
; 			if(key_debug&MAX_RT) SPI_RW_Reg(FLUSH_TX,0);
	lds R2,_key_debug
	sbrs R2,4
	rjmp L9
X2:
	.dbline 142
	clr R18
	ldi R16,225
	rcall _SPI_RW_Reg
L9:
	.dbline 143
; 			SPI_RW_Reg(WRITE_REG+STATUS,0xff);// clear RX_DR or TX_DS or MAX_RT interrupt flag
	ldi R18,255
	ldi R16,39
	rcall _SPI_RW_Reg
	.dbline 144
; 			RX_Mode();
	rcall _RX_Mode
	.dbline 145
; 			if((Buffer[0]==80)&&(Buffer[1]==01))//data accept
	lds R24,_Buffer
	cpi R24,80
	brne L11
X3:
	lds R24,_Buffer+1
	cpi R24,1
	brne L11
X4:
	.dbline 146
; 			{
	.dbline 147
; 			 	accept_flag=1;
	ldi R24,1
	sts _accept_flag,R24
	.dbline 148
; 			 	PORTC = 0x02;
	ldi R24,2
	out 0x8,R24
	.dbline 149
; 				delayms(5000);	//延时10ms*10=100ms
	ldi R16,5000
	ldi R17,19
	rcall _delayms
	.dbline 150
; 				PORTC = 0x00;
	clr R2
	out 0x8,R2
	.dbline 151
; 			}
L11:
	.dbline 152
; 		}
L5:
	.dbline 153
; 		if(accept_flag==0)//data send
	lds R2,_accept_flag
	tst R2
	brne L14
X5:
	.dbline 154
; 		{
	.dbline 155
; 		 		accept_flag=1;
	ldi R24,1
	sts _accept_flag,R24
	.dbline 156
; 				accept_time=0;
	clr R2
	clr R3
	sts _accept_time+1,R3
	sts _accept_time,R2
	.dbline 157
; 		 		Buffer[0]=80;
	ldi R24,80
	sts _Buffer,R24
	.dbline 158
; 				Buffer[1]=02;
	ldi R24,2
	sts _Buffer+1,R24
	.dbline 159
; 				TX_Mode();			// set TX Mode and transmitting
	rcall _TX_Mode
	.dbline 160
; 				Buffer[0]=80;
	ldi R24,80
	sts _Buffer,R24
	.dbline 161
; 				Buffer[1]=02;
	ldi R24,2
	sts _Buffer+1,R24
	.dbline 162
; 				TX_Mode();			// set TX Mode and transmitting
	rcall _TX_Mode
	.dbline 163
; 				delayms(100);
	ldi R16,100
	ldi R17,0
	rcall _delayms
	.dbline 164
; 		}
L14:
	.dbline 165
; 		if(accept_flag=1)
	ldi R24,1
	sts _accept_flag,R24
	tst R24
	breq L18
X6:
	.dbline 166
; 		{
	.dbline 167
; 		   accept_time++;
	lds R24,_accept_time
	lds R25,_accept_time+1
	adiw R24,1
	sts _accept_time+1,R25
	sts _accept_time,R24
	.dbline 168
; 		   delayms(100);
	ldi R16,100
	ldi R17,0
	rcall _delayms
	.dbline 169
; 		   if(accept_time>1000)
	ldi R24,1000
	ldi R25,3
	lds R2,_accept_time
	lds R3,_accept_time+1
	cp R24,R2
	cpc R25,R3
	brsh L20
X7:
	.dbline 170
; 		   {
	.dbline 171
; 		   	 accept_flag=0;
	clr R2
	sts _accept_flag,R2
	.dbline 172
; 			 accept_time=0;
	clr R3
	sts _accept_time+1,R3
	sts _accept_time,R2
	.dbline 173
; 		   }
L20:
	.dbline 174
; 		}	
L18:
	.dbline 175
; 	}
L3:
	.dbline 134
	rjmp L2
X8:
	.dbline -2
L1:
	.dbline 0 ; func end
	adiw R28,1
	ret
	.dbsym r Get_SO 10 c
	.dbend
	.dbfunc e init_CPU _init_CPU fV
	.even
_init_CPU::
	.dbline -1
	.dbline 184
; 
; 
; }
; /*-----------------------------------------------------------------------------
;    Module:   init_CPU
;    Function: Initialization of CPU
; ------------------------------------------------------------------------------*/
; void init_CPU (void)
; {
	.dbline 185
;  	MCUCR = 0x00;	// 
	clr R2
	out 0x35,R2
	.dbline 186
; 	EICRA = 0x00; //extended ext ints
	sts 105,R2
	.dbline 187
;     EIMSK = 0x00;
	out 0x1d,R2
	.dbline 189
; 	 
; 	TIMSK0 = 0x01; //timer 0 interrupt sources
	ldi R24,1
	sts 110,R24
	.dbline 190
; 	TIMSK1 = 0x00; //timer 1 interrupt sources
	sts 111,R2
	.dbline 191
; 	TIMSK2 = 0x00; //timer 2 interrupt sources
	sts 112,R2
	.dbline 192
; 	 CLI(); //disable all interrupts
	cli
	.dbline 193
; 	 NOP();
	nop
	.dbline 194
; 	PORTB = 0x81;
	ldi R24,129
	out 0x5,R24
	.dbline 195
;  	DDRB  = 0xf3;
	ldi R24,243
	out 0x4,R24
	.dbline 196
; 	PORTD = 0x80;
	ldi R24,128
	out 0xb,R24
	.dbline 197
; 	DDRD  = 0xff;
	ldi R24,255
	out 0xa,R24
	.dbline 198
; 	PORTC = 0x80;
	ldi R24,128
	out 0x8,R24
	.dbline 199
; 	DDRC  = 0x78;
	ldi R24,120
	out 0x7,R24
	.dbline 200
;     nRF24L01_CEL;
	cbi 0xb,7
	.dbline 201
; 	delay();
	rcall _delay
	.dbline 202
; 	nRF24L01_CSNH;			// Spi disable
	sbi 0xb,6
	.dbline 203
; 	delay();
	rcall _delay
	.dbline 204
; 	nRF24L01_SCKL;	
	cbi 0x5,1
	.dbline 205
; 	delay();
	rcall _delay
	.dbline -2
L22:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e delay _delay fV
	.even
_delay::
	.dbline -1
	.dbline 208
; }
; void delay(void)//
; {
	.dbline 209
; 	NOP();
	nop
	.dbline 210
; 	NOP();
	nop
	.dbline 211
; 	NOP();
	nop
	.dbline 212
; 	NOP();
	nop
	.dbline 213
; 	NOP();
	nop
	.dbline 214
; 	NOP();
	nop
	.dbline -2
L23:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e delayms _delayms fV
;            dly -> R16,R17
	.even
_delayms::
	.dbline -1
	.dbline 217
; }
; void delayms(unsigned short	dly)//
; {
	.dbline 218
; 	for(;dly>0;dly--) ;
	rjmp L28
L25:
	.dbline 218
L26:
	.dbline 218
	subi R16,1
	sbci R17,0
L28:
	.dbline 218
	cpi R16,0
	cpc R16,R17
	brne L25
X9:
	.dbline -2
L24:
	.dbline 0 ; func end
	ret
	.dbsym r dly 16 s
	.dbend
	.dbfunc e clear_buf _clear_buf fV
;         number -> R18
;            ptr -> R16,R17
	.even
_clear_buf::
	.dbline -1
	.dbline 222
; }
; 
; void clear_buf(unsigned char	*ptr,unsigned char number)//清零buffer,指定字节个数
; {
	.dbline 223
; 	for (;number>0;number--) *ptr++=0;
	rjmp L33
L30:
	.dbline 223
	clr R2
	movw R30,R16
	st Z+,R2
	movw R16,R30
L31:
	.dbline 223
	dec R18
L33:
	.dbline 223
	ldi R24,0
	cp R24,R18
	brlo L30
X10:
	.dbline -2
L29:
	.dbline 0 ; func end
	ret
	.dbsym r number 18 c
	.dbsym r ptr 16 pc
	.dbend
	.dbfunc e SPI_RW _SPI_RW fc
;        bit_ctr -> R22
;           byte -> R20
	.even
_SPI_RW::
	rcall push_xgsetF000
	mov R20,R16
	.dbline -1
	.dbline 234
; }
; //------------------------------------------------------
; /**************************************************
; Function: SPI_RW();
; 
; Description:
;   Writes one byte to nRF24L01, and return the byte read
;   from nRF24L01 during write, according to SPI protocol  */
; /**************************************************/
; unsigned char SPI_RW(unsigned char byte)
; {
	.dbline 236
; 	unsigned char  bit_ctr;	
;    	for(bit_ctr=0;bit_ctr<8;bit_ctr++)   	// output 8-bit
	clr R22
	rjmp L38
L35:
	.dbline 237
;    	{
	.dbline 238
;    		if(byte & 0x80) 
	sbrs R20,7
	rjmp L39
X11:
	.dbline 239
;    			nRF24L01_MOSIH;
	sbi 0x5,0
	rjmp L40
L39:
	.dbline 241
;    		else 
;    			nRF24L01_MOSIL;
	cbi 0x5,0
L40:
	.dbline 242
; 		delay();
	rcall _delay
	.dbline 243
;    		byte = (byte << 1);           		// shift next bit into MSB..
	lsl R20
	.dbline 244
;    		nRF24L01_SCKH;
	sbi 0x5,1
	.dbline 245
; 		delay();
	rcall _delay
	.dbline 246
;  		if(PINB&0x08) byte |= 1;
	sbis 0x3,3
	rjmp L41
X12:
	.dbline 246
	ori R20,1
L41:
	.dbline 247
;    		nRF24L01_SCKL;
	cbi 0x5,1
	.dbline 248
; 		delay();
	rcall _delay
	.dbline 249
;    	}
L36:
	.dbline 236
	inc R22
L38:
	.dbline 236
	cpi R22,8
	brlo L35
X13:
	.dbline 250
;     return(byte);           		  		// return read byte
	mov R16,R20
	.dbline -2
L34:
	.dbline 0 ; func end
	rjmp pop_xgsetF000
	.dbsym r bit_ctr 22 c
	.dbsym r byte 20 c
	.dbend
	.dbfunc e SPI_RW_Reg _SPI_RW_Reg fc
;         status -> R10
;          value -> R12
;            reg -> R10
	.even
_SPI_RW_Reg::
	rcall push_xgset003C
	mov R12,R18
	mov R10,R16
	.dbline -1
	.dbline 259
; }
; /**************************************************
; Function: SPI_RW_Reg();
; 
; Description:
;   Writes value 'value' to register 'reg' */
; /**************************************************/
; unsigned char SPI_RW_Reg(unsigned char reg, unsigned char value)
; {
	.dbline 261
; 	unsigned char status;
; 	nRF24L01_CSNL;
	cbi 0xb,6
	.dbline 262
; 	delay();
	rcall _delay
	.dbline 263
; 	status = SPI_RW(reg);      // select register
	mov R16,R10
	rcall _SPI_RW
	mov R10,R16
	.dbline 264
;   	SPI_RW(value);             // ..and write value to it..
	mov R16,R12
	rcall _SPI_RW
	.dbline 265
; 	nRF24L01_CSNH;
	sbi 0xb,6
	.dbline 266
; 	delay();
	rcall _delay
	.dbline 267
;   	return(status);            // return nRF24L01 status byte
	mov R16,R10
	.dbline -2
L43:
	.dbline 0 ; func end
	rjmp pop_xgset003C
	.dbsym r status 10 c
	.dbsym r value 12 c
	.dbsym r reg 10 c
	.dbend
	.dbfunc e SPI_Read _SPI_Read fc
;        reg_val -> R10
;            reg -> R10
	.even
_SPI_Read::
	st -y,R10
	st -y,R11
	mov R10,R16
	.dbline -1
	.dbline 276
; }
; /**************************************************
; Function: SPI_Read();
; 
; Description:
;   Read one byte from nRF24L01 register, 'reg'  */
; /**************************************************/
; unsigned char SPI_Read(unsigned char reg)
; {
	.dbline 278
; 	unsigned char reg_val;
; 	nRF24L01_CSNL;
	cbi 0xb,6
	.dbline 279
; 	delay();
	rcall _delay
	.dbline 280
;   	SPI_RW(reg);            // Select register to read from..
	mov R16,R10
	rcall _SPI_RW
	.dbline 281
;   	reg_val = SPI_RW(0);    // ..then read registervalue
	clr R16
	rcall _SPI_RW
	mov R10,R16
	.dbline 282
; 	nRF24L01_CSNH;
	sbi 0xb,6
	.dbline 283
; 	delay();
	rcall _delay
	.dbline 284
;   	return(reg_val);        // return register value
	mov R16,R10
	.dbline -2
L44:
	.dbline 0 ; func end
	ld R11,y+
	ld R10,y+
	ret
	.dbsym r reg_val 10 c
	.dbsym r reg 10 c
	.dbend
	.dbfunc e SPI_Read_Buf _SPI_Read_Buf fc
;         status -> R10
;       byte_ctr -> R12
;          bytes -> y+6
;           pBuf -> R14,R15
;            reg -> R10
	.even
_SPI_Read_Buf::
	rcall push_xgset00FC
	movw R14,R18
	mov R10,R16
	.dbline -1
	.dbline 294
; }
; /**************************************************
; Function: SPI_Read_Buf();
; 
; Description:
;   Reads 'bytes' #of bytes from register 'reg'
;   Typically used to read RX payload, Rx/Tx address */
; /**************************************************/
; unsigned char SPI_Read_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)
; {
	.dbline 296
; 	unsigned char status,byte_ctr;
; 	nRF24L01_CSNL;
	cbi 0xb,6
	.dbline 297
; 	delay();
	rcall _delay
	.dbline 298
;   	status = SPI_RW(reg);       		// Select register to write to and read status byte
	mov R16,R10
	rcall _SPI_RW
	mov R10,R16
	.dbline 299
; 	for(byte_ctr=0;byte_ctr<bytes;byte_ctr++)
	clr R12
	rjmp L49
L46:
	.dbline 300
;     	pBuf[byte_ctr] = SPI_RW(0);    // Perform SPI_RW to read byte from nRF24L01
	clr R16
	rcall _SPI_RW
	mov R30,R12
	clr R31
	add R30,R14
	adc R31,R15
	std z+0,R16
L47:
	.dbline 299
	inc R12
L49:
	.dbline 299
	ldd R0,y+6
	cp R12,R0
	brlo L46
X14:
	.dbline 301
; 	nRF24L01_CSNH;
	sbi 0xb,6
	.dbline 302
; 	delay();
	rcall _delay
	.dbline 303
;   	return(status);                    // return nRF24L01 status byte
	mov R16,R10
	.dbline -2
L45:
	.dbline 0 ; func end
	rjmp pop_xgset00FC
	.dbsym r status 10 c
	.dbsym r byte_ctr 12 c
	.dbsym l bytes 6 c
	.dbsym r pBuf 14 pc
	.dbsym r reg 10 c
	.dbend
	.dbfunc e SPI_Write_Buf _SPI_Write_Buf fc
;         status -> R10
;       byte_ctr -> R12
;          bytes -> y+6
;           pBuf -> R14,R15
;            reg -> R10
	.even
_SPI_Write_Buf::
	rcall push_xgset00FC
	movw R14,R18
	mov R10,R16
	.dbline -1
	.dbline 313
; }
; /**************************************************
; Function: SPI_Write_Buf();
; 
; Description:
;   Writes contents of buffer '*pBuf' to nRF24L01
;   Typically used to write TX payload, Rx/Tx address */
; /**************************************************/
; unsigned char SPI_Write_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)
; {
	.dbline 315
; 	unsigned char status,byte_ctr;
; 	nRF24L01_CSNL;                   		// Set nRF24L01_CSN low, init SPI tranaction
	cbi 0xb,6
	.dbline 316
;   	delay();
	rcall _delay
	.dbline 317
; 	status = SPI_RW(reg);    					// Select register to write to and read status byte
	mov R16,R10
	rcall _SPI_RW
	mov R10,R16
	.dbline 318
;   	for(byte_ctr=0; byte_ctr<bytes; byte_ctr++) // then write all byte in buffer(*pBuf)
	clr R12
	rjmp L54
L51:
	.dbline 319
;     	status = SPI_RW(*pBuf++);            
	movw R30,R14
	ld R16,Z+
	movw R14,R30
	rcall _SPI_RW
	mov R10,R16
L52:
	.dbline 318
	inc R12
L54:
	.dbline 318
	ldd R0,y+6
	cp R12,R0
	brlo L51
X15:
	.dbline 320
; 	nRF24L01_CSNH; 								// Set nRF24L01_CSN high again
	sbi 0xb,6
	.dbline 321
; 	delay();
	rcall _delay
	.dbline 322
;   	return(status);          					// return nRF24L01 status byte
	mov R16,R10
	.dbline -2
L50:
	.dbline 0 ; func end
	rjmp pop_xgset00FC
	.dbsym r status 10 c
	.dbsym r byte_ctr 12 c
	.dbsym l bytes 6 c
	.dbsym r pBuf 14 pc
	.dbsym r reg 10 c
	.dbend
	.dbfunc e RX_Mode _RX_Mode fV
	.even
_RX_Mode::
	sbiw R28,1
	.dbline -1
	.dbline 335
; }
; /**************************************************
; Function: RX_Mode();
; 
; Description:
;   This function initializes one nRF24L01 device to
;   RX Mode, set RX address, writes RX payload width,
;   select RF channel, datarate & LNA HCURR.
;   After init, CE is toggled high, which means that
;   this device is now ready to receive a datapacket. */
; /**************************************************/
; void RX_Mode(void)
; {
	.dbline 336
; 	nRF24L01_CEL;
	cbi 0xb,7
	.dbline 337
; 	delay();
	rcall _delay
	.dbline 338
;   	SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH); // Use the same address on the RX device as the TX device
	ldi R24,5
	std y+0,R24
	ldi R18,<_TX_ADDRESS
	ldi R19,>_TX_ADDRESS
	ldi R16,42
	rcall _SPI_Write_Buf
	.dbline 340
; 
;   	SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);      // Enable Auto.Ack:Pipe0
	ldi R18,1
	ldi R16,33
	rcall _SPI_RW_Reg
	.dbline 341
;   	SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);  // Enable Pipe0
	ldi R18,1
	ldi R16,34
	rcall _SPI_RW_Reg
	.dbline 342
;   	SPI_RW_Reg(WRITE_REG + RF_CH, 40);        // Select RF channel 40
	ldi R18,40
	ldi R16,37
	rcall _SPI_RW_Reg
	.dbline 343
;   	SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH); // Select same RX payload width as TX Payload width
	ldi R18,20
	ldi R16,49
	rcall _SPI_RW_Reg
	.dbline 344
;   	SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);   // TX_PWR:0dBm, Datarate:2Mbps, LNA:HCURR
	ldi R18,7
	ldi R16,38
	rcall _SPI_RW_Reg
	.dbline 345
;   	SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);     // Set PWR_UP bit, enable CRC(2 bytes) & Prim:RX. RX_DR enabled..
	ldi R18,15
	ldi R16,32
	rcall _SPI_RW_Reg
	.dbline 346
;   	nRF24L01_CEH;
	sbi 0xb,7
	.dbline 347
; 	delay();
	rcall _delay
	.dbline -2
L55:
	.dbline 0 ; func end
	adiw R28,1
	ret
	.dbend
	.dbfunc e TX_Mode _TX_Mode fV
	.even
_TX_Mode::
	sbiw R28,1
	.dbline -1
	.dbline 367
; 	//  This device is now ready to receive one packet of 16 bytes payload from a TX device sending to address
;   //  '3443101001', with auto acknowledgment, retransmit count of 10, RF channel 40 and datarate = 2Mbps.
; 
; }
; /**************************************************/
; 
; /**************************************************
; Function: TX_Mode();
; 
; Description:
;   This function initializes one nRF24L01 device to
;   TX mode, set TX address, set RX address for auto.ack,
;   fill TX payload, select RF channel, datarate & TX pwr.
;   PWR_UP is set, CRC(2 bytes) is enabled, & PRIM:TX.
; 
;   ToDo: One high pulse(>10us) on CE will now send this
;   packet and expext an acknowledgment from the RX device. */
; /**************************************************/
; void TX_Mode(void)
; {
	.dbline 368
; 	nRF24L01_CEL;
	cbi 0xb,7
	.dbline 369
; 	delay();
	rcall _delay
	.dbline 370
;   	SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // Writes TX_Address to nRF24L01
	ldi R24,5
	std y+0,R24
	ldi R18,<_TX_ADDRESS
	ldi R19,>_TX_ADDRESS
	ldi R16,48
	rcall _SPI_Write_Buf
	.dbline 371
;   	SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH); // RX_Addr0 same as TX_Adr for Auto.Ack
	ldi R24,5
	std y+0,R24
	ldi R18,<_TX_ADDRESS
	ldi R19,>_TX_ADDRESS
	ldi R16,42
	rcall _SPI_Write_Buf
	.dbline 372
;   	SPI_Write_Buf(WR_TX_PLOAD, Buffer, TX_PLOAD_WIDTH); // Writes data to TX payload
	ldi R24,20
	std y+0,R24
	ldi R18,<_Buffer
	ldi R19,>_Buffer
	ldi R16,160
	rcall _SPI_Write_Buf
	.dbline 374
; 
;   	SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);      // Enable Auto.Ack:Pipe0
	ldi R18,1
	ldi R16,33
	rcall _SPI_RW_Reg
	.dbline 375
;   	SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);  // Enable Pipe0
	ldi R18,1
	ldi R16,34
	rcall _SPI_RW_Reg
	.dbline 376
;   	SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x1a); // 500us + 86us, 10 retrans...
	ldi R18,26
	ldi R16,36
	rcall _SPI_RW_Reg
	.dbline 377
;   	SPI_RW_Reg(WRITE_REG + RF_CH, 40);        // Select RF channel 40
	ldi R18,40
	ldi R16,37
	rcall _SPI_RW_Reg
	.dbline 378
;   	SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);   // TX_PWR:0dBm, Datarate:2Mbps, LNA:HCURR
	ldi R18,7
	ldi R16,38
	rcall _SPI_RW_Reg
	.dbline 379
;   	SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);     // Set PWR_UP bit, enable CRC(2 bytes) & Prim:TX. MAX_RT & TX_DS enabled..
	ldi R18,14
	ldi R16,32
	rcall _SPI_RW_Reg
	.dbline 380
; 	nRF24L01_CEH;
	sbi 0xb,7
	.dbline 381
; 	delay();
	rcall _delay
	.dbline -2
L56:
	.dbline 0 ; func end
	adiw R28,1
	ret
	.dbend
	.area bss(ram, con, rel)
	.dbfile E:\sendavrnrf24l01\main.c
_key_debug::
	.blkb 1
	.dbsym e key_debug _key_debug c
; 	
; }
; //------------------------------------------------------
