/*
 * TouchPad_Long_Short_Mealy
 * 硬件描述：P1.0和P1.6分别接了1个红光LED和1个绿光LED（用跳线帽连接），P2.0和P2.5引出两个触摸板
 * 功能描述：短按下P2.0触摸板切换红灯亮灭，长按下P2.0切换绿灯亮灭。
 * 备       注：套用机械按键的状态机，判断长短键
 *  Created on: 2013-4-8
 *  Author: Administrator
 */
#include "MSP430G2553.h"
#include "TouchIN.h"

//-----对状态进行宏定义-----
#define IDLE						0
#define SHORT					1
#define LONG					2

#define COUNTER_THRESHOLD   30		/*长键判别门限*/

//-----全局变量-----
unsigned char WDT_Counter=0;				/*用于对按键按下时间进行计数*/

//-----在main函数前提前申明函数----
void GPIO_init();
void WDT_init();
void Key_SM();
unsigned char LongClick_Dect();
void P20_Touch_OnShortRelease();
void P20_Touch_OnLongClick();

/******为符合阅读习惯，将main函数放最前面，但其他函数就必须提前声明***/
void main(void) {
	WDTCTL = WDTPW + WDTHOLD;	//关狗
	GPIO_init();
	WDT_init();
	_enable_interrupts();
	_bis_SR_register(LPM3_bits);
}

/******************************************************************************************************
 * 名       称：GPIO_Init()
 * 功       能：设定按键和LED控制IO的方向，启用按键IO的上拉电阻
 * 入口参数：无
 * 出口参数：无
 * 说       明：使用触摸按键时，无需使用内部上下拉点
 * 范       例：无
 ******************************************************************************************************/
void GPIO_init()
{
	//-----设定P1.0和P1.6的输出初始值-----------
	P1DIR |= BIT0+BIT6;				//设定P1.0和P1.6为输出
	P1OUT |= BIT0;						//设定P1.0初值
	P1OUT &= ~BIT6;					//设定P1.6初值
//	//-----使用P2.0触摸按键，不用P1.3机械按键了-------
//	P1REN |= BIT3;				        //启用P1.3内部上下拉电阻
//	P1OUT |= BIT3;			            //将电阻设置为上拉
}
/******************************************************************************************************
 * 名       称：WDT_init()
 * 功       能：设定WDT定时中断为16ms，开启WDT定时中断使能
 * 入口参数：无
 * 出口参数：无
 * 说       明：WDT定时中断的时钟源选择ACLK，可以用LPM3休眠。
 * 范       例：无
 ******************************************************************************************************/
void WDT_init()
{
	//-----设定WDT为-----------
	WDTCTL=WDT_ADLY_16;
	//-----WDT中断使能----------------------
    IE1|=WDTIE;
}
/******************************************************************************************************
 * 名       称：WDT_ISR()
 * 功       能：响应WDT定时中断服务
 * 入口参数：无
 * 出口参数：无
 * 说       明：不能直接判断事件，需启用状态机
 * 范       例：无
 ******************************************************************************************************/
#pragma vector=WDT_VECTOR
__interrupt void WDT_ISR(void)
{
	//-----触摸按键状态检测程序必须定时调用---
	TouchIN_Dect();
	//----启用按键状态机----
	Key_SM();
}
/******************************************************************************************************
 * 名       称：Key_SM()
 * 功       能：判断出长短键
 * 入口参数：无
 * 出口参数：无
 * 说       明：本状态机为Mealy型状态机，在Switch(State)中需要判断事件
 * 范       例：无
 ******************************************************************************************************/
void Key_SM()
{
	static unsigned char State;					//状态机的状态变量
	static unsigned char Key_Now;			//记录按键的当前电平
	unsigned char Key_Past=0;					//记录按键的前一次电平
	unsigned char Key_Dect=0;					//按键状态值
	Key_Past=Key_Now;
	//-----查询IO的输入寄存器-----
//	if(P1IN&BIT3) 	Key_Now=1;
	if(TouchIN&BIT0) 	Key_Now=1;			//由P1.3改为TouchIN.0
	else 					Key_Now=0;
	//----- 触摸识别前0后1，表明按下-----
//	if((Key_Past==1)&&(Key_Now==0))
	if((Key_Past==0)&&(Key_Now==1))		//与机械按键的逻辑相反
		Key_Dect=1;
	//----- 触摸识别前1后0，表明松开-----
	if((Key_Past==1)&&(Key_Now==0))		//与机械按键的逻辑相反
		Key_Dect=2 ;
	switch(State)			//该状态机靠扫描的按键值Key_Dect跳转状态
	{
	case IDLE:  		WDT_Counter=0;					//空闲状态对计数清零
							if(Key_Dect==1) 	State=SHORT;	break;	//路径1
	case SHORT:  	if(Key_Dect==2)										   	//路径2
								{
									State=IDLE;
//									P13_OnShortRelease();		//短按事件处理函数
									P20_Touch_OnShortRelease();	//改为P2.0触摸短按事件处理函数
								}
							if(LongClick_Dect())									//路径3
								{
									State=LONG;
//									P13_OnLongClick();			//长按事件处理函数
									P20_Touch_OnLongClick();		//改为P2.0触摸长按事件处理函数
								}
																					break;
	case LONG:		 WDT_Counter=0; 					//长按状态对计数清零
							if(Key_Dect==2) 	State=IDLE;		break;	 //路径4
	default: 			State=IDLE;										break;
	}
}

/******************************************************************************************************
 * 名       称：LongClick_Dect()
 * 功       能：对WDT中断计时，计满清零并返回”长键“信息
 * 入口参数：无
 * 出口参数：无
 * 说       明：
 * 范       例：无
 ******************************************************************************************************/
unsigned char LongClick_Dect()
{
	WDT_Counter++;
	if (WDT_Counter==COUNTER_THRESHOLD)
	{
		WDT_Counter=0;
		return(1);
	}
	else return(0);
}
/******************************************************************************************************
 * 名       称：P20_Touch_OnShortRelease()
 * 功       能：P2.0的触摸短按事件处理函数，即当P2.0触摸键被”短按“后，下一步干什么
 * 入口参数：无
 * 出口参数：无
 * 说       明：使用事件处理函数的形式，可以增强代码的移植性和可读性
 * 范       例：无
 ******************************************************************************************************/
void P20_Touch_OnShortRelease()					//P1.3的事件处理函数
{
	//----翻转IO电平-----
	P1OUT ^= BIT0;
}
/******************************************************************************************************
 * 名       称：P20_Touch_OnLongClick()
 * 功       能：P2.0的触摸长按事件处理函数，即当P2.0触摸键被”长按“后，下一步干什么
 * 入口参数：无
 * 出口参数：无
 * 说       明：使用事件处理函数的形式，可以增强代码的移植性和可读性
 * 范       例：无
 ******************************************************************************************************/
void P20_Touch_OnLongClick()					//P1.3的事件处理函数
{
	//----翻转IO电平-----
	P1OUT ^= BIT6;
}
