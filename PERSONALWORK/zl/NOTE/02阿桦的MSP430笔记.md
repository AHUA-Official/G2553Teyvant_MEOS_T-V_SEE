# 02阿桦的MSP430笔记



###### 01  led呼吸灯

```c
#include <msp430.h>				
//关于串口,寄存器等的配置文件,内部引入了msp430系列的所有单片机的配置头文件,要看具体的配置文件去翻
//#elif defined (__MSP430G2353__)
//#include "msp430g2353.h"这是内部对g2553的引入,把具体的寄存器的地址宏定义为WDTCTL,P1out之类的英语单词,现在我们就可以看懂代码了
//在以后的文档中,我会对这样的宏定义进行说明,如果涉及到的电路的配置或者输入输出我懂的话也会予以说明

/**
 * blink.c
 @brief led灯的呼吸
 */
void main(void)
{
	WDTCTL = WDTPW | WDTHOLD;		// stop watchdog timer
  //WDTCTL  Watchdog Timer看门狗 控制寄存器
  //WDTPW 看门狗 密码 解锁对看门狗寄存器的写入
  //WDTHOLD  看嘛狗停止位  置1停止看门狗 置0启用
  // | 按位或运算   WDTPW | WDTHOLD   停止Watchdog Timer 并解锁对 WDTCTL 寄存器的写入  
  //这样可以防止看门狗复位或干扰代码执行   
  //注释,这样的代码,后面我们学会了Grace可视化界面配置就不用自己写了
  
  
  
	P1DIR |= 0x01;					// configure P1.0 as output
    //  0000 0001 
  //P1DIR输入输出端口,寄存器配置,一位对应一个开关或者之类的,类似家里面的电闸
  //使用按位或方法,不会影响到其他位的情况下把最后一位确保为1   现在对应的输入/输出模式是将 P1.0 配置为输出模式，用于驱动外部设备
  

	volatile unsigned int i;		// volatile to prevent optimization
//定义计数器,用来实现延时模块,
  //volatile 修饰符告诉编译器不要对 i 进行优化，因为 i 可能会在代码中的其他地方被改变。通常在延时循环中使用 volatile 变量，以确保编译器不会优化掉这些延时操作。不然如果编译器把咱们循环1万条--的延时模块给优化了,我们就延不了时了
	while(1)
      //单片机开发的死循环,类似的写法有for(;;),不过这没有while(1)直观好看可靠
	{
		P1OUT ^= 0x01;				// toggle P1.0
      //脚的电平状态置反 用抑或模块
      //置1 是高电平,led亮   0 低电平 led熄灭
      //每次执行这一句代码,p1.0的电位就会变化,这样就可以亮灭了
		for(i=10000; i>0; i--);     // delay
      //延时模块,延时了执行一万句的时间,具体的时间要看具体的单片机
	}
}

```



02 