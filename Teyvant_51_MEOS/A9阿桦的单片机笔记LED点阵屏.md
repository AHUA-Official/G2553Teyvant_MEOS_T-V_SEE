照片海   AHUA_MEOS_PICTSEA

# A9阿桦的单片机笔记LED点阵屏

•LED点阵屏分类

  按颜色：单色、双色、全彩

  按像素：8*8、16*16等（大规模的LED点阵通常由很多个小点阵拼接而成）\

•LED点阵屏的结构类似于数码管，只不过是数码管把每一列的像素以“8”字型排列而已

•LED点阵屏与数码管一样，有共阴和共阳两种接法，不同的接法对应的电路结构不同

###### •LED点阵屏需要进行逐行或逐列扫描，才能使所有LED同时显示

•74HC595是串行输入并行输出的移位寄存器，可用3根线输入串行数据，8根线输出并行数据，多片级联后，可输出16位、24位、32位等，常用于IO口扩展。不知道 不会 看不懂

这个地方涉及到的模电和数电的知识

不知道  我不会,不想学,学不懂,

这个文档我不写这些东西的喵

![](AHUA_MEOS_PICTSEA\led_串转并.png)













![](AHUA_MEOS_PICTSEA\led.png)

•sfr（special function register）：特殊功能寄存器声明

  例：sfrP0 = 0x80;

  声明P0口寄存器，物理地址为0x80

•sbit（special bit）：特殊位声明

  例：sbitP0_1 = 0x81;    或   sbit P0_1 = P0^1;

  声明P0寄存器的第1位

•可位寻址/不可位寻址：在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址，又因为一个寄存器里有8位，所以位的数量是寄存器数量的8倍，单片机无法对所有位进行编码，故每8个寄存器中，只有一个是可以位寻址的。对不可位寻址的寄存器，若要只操作其中一位而不影响其它位时，可用“&=”、“|=”、“^=”的方法进行位操作

## 项目1静态图像

```c
//@author AHUA
//@version Teyvant1.00
//@create 2023/9/8
//@brief 一个笑脸


#include <REGX52.H>
//在头文件我们会看到的sfr 比如什么
//sfr P0 = 0x80;     // 用 P0 这个名字来表示 0x80 地址处的特殊功能寄存器
///sfr P1 = 0x90;     // 用 P1 这个名字来表示 0x90 地址处的特殊功能寄存器
//sfr TCON = 0x88;   // 用 TCON 这个名字来表示 0x88 地址处的特殊功能寄存器
//sfr TMOD = 0x89;   // 用 TMOD 这个名字来表示 0x89 地址处的特殊功能寄存器
//sfr SBUF = 0x99;   // 用 SBUF 这个名字来表示 0x99 地址处的特殊功能寄存器
//sfr 是一个关键字，用于在嵌入式系统中定义特殊功能寄存器（Special Function Registers）。在嵌入式系统中，特殊功能寄存器用于与外部硬件交互、配置和控制微控制器的各种功能。

//通过 sfr 关键字，你可以为特殊功能寄存器分配一个易于理解的名字，以便在代码中更方便地引用它们。通常，特殊功能寄存器控制着微控制器的输入输出引脚、定时器、串口通信、中断控制等。
//用来定义寄存器变量的



#include "Delay.h"//头文件的引入
//sbit表示的意思是
//sbit 是一种特殊的关键字，用于声明一个特定的位（Bit）变量，通常用于操作单片机的输入输出引脚（IO口）。sbit 通常与寄存器位操作结合使用，用于直接控制和监测单片机的引脚状态。,申明寄存器的某一位的把他拿给变量来操作和赋值
sbit RCK=P3^5;		//RCLK  上升沿锁存  p3 第5 位  0xb5
//输出时钟：通过 RCLK（Register Clock Input）引脚，你可以将寄存器中的数据并行输出到输出引脚
//串行 并行是什么东西?
//串行单线逐位顺序慢
//并行多线同时一起快
//
//串行和并行是两种不同的数据传输方式，它们用于将信息从一个地方传输到另一个地方，但在传输方式和速度上有一些重要的区别。

//串行传输：

//逐位传输：串行传输是逐位传输数据的方式。每个数据位依次传输，一个接一个。
//单线传输：通常，串行传输只需要一条数据线来传输数据。此外，通常还有一个时钟线来同步数据传输，确保发送端和接收端的时钟同步。
//顺序传输：数据位按照固定的顺序传输，从最高位到最低位或者反过来。
//较慢但省线：由于逐位传输，串行传输通常比并行传输慢，但它节省了线缆和引脚。
//并行传输：

//同时传输多个位：并行传输是一种同时传输多个位的方式，每个数据位都有自己的数据线。
//多线传输：并行传输需要多条数据线，每个数据位都有自己的线，因此需要更多的线缆和引脚。
//并发传输：数据位可以同时传输，因此并行传输通常比串行传输更快。
//速度较快但占用空间：由于并行传输可以同时传输多个位，因此它通常比串行传输快速，但需要更多的线缆和引脚，因此在占用空间上更多。


sbit SCK=P3^6;		//SRCLK  上升沿移位
//串行时钟：通过 SRCLK（Serial Clock Input）引脚，你可以提供时钟脉冲来推进数据输入。
sbit SER=P3^4;		//SER  
//串行输入：通过 SER（Serial Data Input）引脚，你可以将数据以串行方式输入到寄存器。
//使用^的原因
//可位寻址/不可位寻址：在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址，又因为一个寄存器里有8位，所以位的数量是寄存器数量的8倍，单片机无法对所有位进行编码，故每8个寄存器中，只有一个是可以位寻址的。对不可位寻址的寄存器，若要只操作其中一位而不影响其它位时，可用“&=”、“|=”、“^=”的方法进行位操作
//&= 操作符用于将某个位清零（置0），其他位不受影响。
//|= 操作符用于将某个位设置为1，其他位不受影响。
//^= 操作符用于翻转某个位（将1变为0，将0变为1），其他位不受影响。
//看下面一个C文件给操作
//谁可以位寻址,谁不可以,看文档

//这里我们操作的是74HC595的板块,这个东西大家知道的,拿来用3个可以操作LED的8个

//给控制点阵屏的p0口一个好的名字
//p0口接的是点阵屏上列的接口开关,每一位对应一列上的应交        该位置0  置低电平 表示这个应交接通了
#define MATRIX_LED_PORT		P0

/**
  * @brief  74HC595写入一个字节 最终给8 个 ,然后
  * @param  Byte 要写入的字节
  * @retval 无
  */
void _74HC595_WriteByte(unsigned char Byte)//写入字节数据  ,8位的byte
{
	unsigned char i;//定义i 拿来取8位的
	for(i=0;i<8;i++)
	{//SER=Byte&0x80 刚开始的时候
      //1000 0000   Byte 中的最高位（即最左边的位）被保留，而其他位被清零。  然后 这样的 话  就可以最高1的话,ser就是高电平,最高是0 的话,ser就是低电平了
   //ser只有两种状态,给赋值为0的时候,就是低电平,为正的时候,就是高电平
      //非0 就是1
      //所以这样我们就把byte最高位的数据拿给了ser,
      
		SER=Byte&(0x80>>i);
      //现在每次把1 往右移动一位,就可以让ser依次获得次最高位,次次最高位的数据,然后把他装进去的了
		SCK=1;//给上升位置1 高电平 ,然后就把一位数据放进去了,
		SCK=0;//置0 ,给下一次往下走一位作装备,
      //sck每次出现一次从0到1,低电平到高电平的转换的时候就会往下移动一位,这个时候就去读ser的值给他装进去
	}
  //现在我们的74HC895的寄存器里面已经存好了8位的数据,现在我们要把这些数据上传给io口,只需要操作上升沿锁存
  //上升沿锁存RCLK每次从0到1 从低电平到高电平,就把寄存器里装的8位数据传给io口一次
	RCK=1;
	RCK=0;
}

/**
  * @brief  LED点阵屏显示一列数据
  * @param  Column 要选择的列，范围：0~7，0在最左边
  * @param  Data 选择列显示的数据，高位在上，1为亮，0为灭
  * @retval 无
  */
void MatrixLED_ShowColumn(unsigned char Column,Data)
{//采用按列扫描的方式
	_74HC595_WriteByte(Data);//获得每一行的内容
	MATRIX_LED_PORT=~(0x80>>Column);//获得扫描的列数,我们对置0好的东西喜欢用取反操作,这样好算,方便
	Delay(1);//延时一下,不然一直闪,而且光很淡很淡,根本看不出来灯在亮
	MATRIX_LED_PORT=0xFF;//初始化列接口
}

void main()
{
	SCK=0;
	RCK=0;
  //上升移位  上升沿锁的置0 低电平初始化
	while(1)
	{
		MatrixLED_ShowColumn(0,0x3C);
		MatrixLED_ShowColumn(1,0x42);
		MatrixLED_ShowColumn(2,0xA9);
		MatrixLED_ShowColumn(3,0x85);
		MatrixLED_ShowColumn(4,0x85);
		MatrixLED_ShowColumn(5,0xA9);
		MatrixLED_ShowColumn(6,0x42);
		MatrixLED_ShowColumn(7,0x3C);
      //一个笑脸的数据
	}
}


```



![](AHUA_MEOS_PICTSEA\led_位寻址表.png)

```c
//@author AHUA
//@version Teyvant1.00
//@create 2023/9/8
//@brief  给一个关于寄存器,寄存器某一位 ,就是操作寄存器的位与、位或和位异或的示例

#include <REGX52.H> 

// 定义特殊功能寄存器的地址
sfr CONTROL_REGISTER = 0x80; // 假设控制寄存器的地址是0x80

void main() {
    // 假设要控制位0的状态
    bit bitToControl = 0;  // 初始化为0，表示关闭设备
    
    // 打开设备，将位0设置为1
    bitToControl |= 1;  // 使用位或操作符将位0设置为1，其他位不受影响
    CONTROL_REGISTER |= bitToControl;  // 更新特殊功能寄存器的位
    
    // 关闭设备，将位0清零
    bitToControl &= 0;  // 使用位与操作符将位0清零，其他位不受影响
    CONTROL_REGISTER &= ~bitToControl;  // 更新特殊功能寄存器的位
    
    // 切换设备状态，将位0翻转
    bitToControl ^= 1;  // 使用位异或操作符翻转位0，其他位不受影响
    CONTROL_REGISTER ^= bitToControl;  // 更新特殊功能寄存器的位
}

```



## 项目2流动的字

```c
//main
#include <REGX52.H>
#include "Delay.h"
#include "MatrixLED.h"
//头文件的引入喵
//动画数据
unsigned char code Animation[]={
/*--  文字:  A  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16 ,错了,但问题不大,可以先看一个字母的上半段,再看下半段,问题不大,不会有人打我的  --*/
0x00,0x00,0x03,0x1C,0x07,0x00,0x00,0x00,0x04,0x3C,0xC4,0x40,0x40,0xE4,0x1C,0x04,

/*--  文字:  H  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x10,0x00,0x00,0x10,0x1F,0x10,0x04,0xFC,0x84,0x80,0x80,0x84,0xFC,0x04,

/*--  文字:  U  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x10,0x00,0x00,0x10,0x1F,0x10,0x00,0xF8,0x04,0x04,0x04,0x04,0xF8,0x00,

/*--  文字:  A  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x03,0x1C,0x07,0x00,0x00,0x00,0x04,0x3C,0xC4,0x40,0x40,0xE4,0x1C,0x04,

/*--  文字:  _  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

/*--  文字:  S  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x0E,0x11,0x10,0x10,0x10,0x1C,0x00,0x00,0x1C,0x04,0x84,0x84,0x44,0x38,0x00,

/*--  文字:  U  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x10,0x00,0x00,0x10,0x1F,0x10,0x00,0xF8,0x04,0x04,0x04,0x04,0xF8,0x00,

/*--  文字:  P  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x10,0x10,0x10,0x10,0x0F,0x00,0x04,0xFC,0x84,0x80,0x80,0x80,0x00,0x00,

/*--  文字:  E  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x11,0x11,0x17,0x10,0x08,0x00,0x04,0xFC,0x04,0x04,0xC4,0x04,0x18,0x00,

/*--  文字:  R  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x11,0x11,0x11,0x11,0x0E,0x00,0x04,0xFC,0x04,0x00,0xC0,0x30,0x0C,0x04,

/*--  文字:  _  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

/*--  文字:  C  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x03,0x0C,0x10,0x10,0x10,0x10,0x1C,0x00,0xE0,0x18,0x04,0x04,0x04,0x08,0x10,0x00,

/*--  文字:  U  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x10,0x00,0x00,0x10,0x1F,0x10,0x00,0xF8,0x04,0x04,0x04,0x04,0xF8,0x00,

/*--  文字:  T  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x18,0x10,0x10,0x1F,0x10,0x10,0x18,0x00,0x00,0x00,0x04,0xFC,0x04,0x00,0x00,0x00,

/*--  文字:  E  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x10,0x1F,0x11,0x11,0x17,0x10,0x08,0x00,0x04,0xFC,0x04,0x04,0xC4,0x04,0x18,0x00,

/*--  文字:  _  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

/*--  文字:  !  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xCC,0x00,0x00,0x00,0x00,
};

void main()
{
	unsigned char i,Offset=0,Count=0;//定义了
  //i
  //offset 偏移量,每播放完一帧动画之后向右走一个
  //Count,每帧动画扫描显示的次数
	MatrixLED_Init();//初始化
	while(1)
	{
		for(i=0;i<8;i++)	//循环8次，显示8列数据
		{
			MatrixLED_ShowColumn(i,Animation[i+Offset]);
		}//映射一帧动画
		Count++;			//计次延时
		if(Count>50)
		{
			Count=0;
			Offset+=8;		//偏移+1，画面往下面走
			if(Offset>16*20)
			{
				Offset=0;
			}///播完了,重复播放
		}
	}
}


```



```c
//"MatrixLED.h"
//ifndef防止重复定义
#ifndef __MATRIX_LED_H__
#define __MATRIX_LED_H__
//@brief 点阵屏初始化
void MatrixLED_Init();
//点阵显示一列数据
void MatrixLED_ShowColumn(unsigned char Column,Data);
void _74HC595_WriteByte(unsigned char Byte);//写入数据


#endif
```

```c
//"MatrixLED.c"

#include <REGX52.H>
#include "Delay.h"
//头文件引入
sbit RCK=P3^5;		//RCLK
sbit SCK=P3^6;		//SRCLK
sbit SER=P3^4;		//SER
//上升沿移 上升沿锁 SER的给一个好看的名字
#define MATRIX_LED_PORT		P0
//点阵列总接口的好名字
/**
  * @brief  74HC595写入一个字节
  * @param  Byte 要写入的字节
  * @retval 无
  */
void _74HC595_WriteByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		SER=Byte&(0x80>>i);
		SCK=1;
		SCK=0;
	}
	RCK=1;
	RCK=0;
}//看项目1 ,懒得再写一遍这个函数了

/**
  * @brief  点阵屏初始化
  * @param  无
  * @retval 无
  */
void MatrixLED_Init()
{
	SCK=0;
	RCK=0;
}//同理,看上面项目1 的注释

/**
  * @brief  LED点阵屏显示一列数据
  * @param  Column 要选择的列，范围：0~7，0在最左边
  * @param  Data 选择列显示的数据，高位在上，1为亮，0为灭
  * @retval 无
  */
void MatrixLED_ShowColumn(unsigned char Column,Data)
{
	_74HC595_WriteByte(Data);
	MATRIX_LED_PORT=~(0x80>>Column);
	Delay(1);
	MATRIX_LED_PORT=0xFF;
}

```

